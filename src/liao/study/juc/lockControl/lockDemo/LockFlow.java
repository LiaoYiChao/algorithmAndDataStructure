package liao.study.juc.lockControl.lockDemo;

import java.util.concurrent.TimeUnit;

/*
 * @description: 锁执行机制
 *                  学习自：尚硅谷-周阳-juc
 *
 *  多线程编写步骤： 判断/干活/通知
 *                  防止虚假唤醒
 *
 *  对象锁，全局锁，局部锁（方法锁）
 *      对象锁，类似 Phone phone = new Phone();
 *                  phone 其中拥有用 synchronized 修饰的同步方法，当多个线程访问使用同一个phone对象进行访问时，
 *                      有且允许一个线程访问 加锁的同步方法，其他想访问的需要轮到才能执行
 *
 *      全局锁，即 静态同步锁，该锁，锁的是全局，非对象， 即无论是一个对象还是多个对象下的多线程，都需要按照锁的规则进行。
 *              类似，多个人用不同的需要电的东西，东西即对象，人为线程，但电即为全局，
 *
 *      方法锁：即只锁方法，除非访问该方法，否则没有影响。
 *
 *
 *  1：标准访问，请问先打印邮件还是短信。
 *      对象锁：先打印邮件，后短信
 *
 *  2：暂停四秒在邮件方法，请问先打印邮件还是短信。
 *      对象锁：先邮件，后短信
 *
 *  3：新增普通sayHello方法，请问先打印邮件还是hello。
 *      普通方法，非同步方法，并不受锁的影响，所以先hello，后邮件，因为邮件方法中线程休眠的一下。
 *
 *  4：两部手机，请问先打印邮件还是短信。
 *      对象锁，但因为是两个对象，所有互不影响。
 *
 *  5：两个静态同步方法，同一部手机，请问先打印邮件还是短信。
 *      全局锁，效果和只有一个对象锁一致，即先拿到对象的线程先进行。 先邮件后短信
 *
 *  6：两个静态同步方法，两部手机，请问先打印邮件还是短信。
 *      因为已经上升至全局锁，所以即便多个对象，但还是和只有一个对象一样。 先邮件后短信
 *
 *  7：一个静态同步方法，一个普通同步方法，同一部手机，请问先打印邮件还是短信。
 *      静态同步-全局 普通同步-对象 同一部手机，结果和同一个对象一致。 先邮件后短信
 *
 *  8：一个静态同步方法，一个普通同步方法，两部手机，请问先打印邮件还是短信。
 *      先短信后邮件，原因两部手机，即两个对象，如果都为同步方法是互不影响状态，但因为其中某个为静态同步，对该方法而言，是全局，
 *          但并不影响其他普通同步方法，所以当有两个对象的时候，是不影响的。
 *
 *
 *
 *  笔记：他人总结 - 尚硅谷-周阳
 *      1：一个对象里面如果有多个 synchronized 方法，某一个时刻内，只要一个线程去调用其中的一个 synchronized 方法了，其他的线程都只能
 *      等待，总的来说，某一个时刻，有且只有一个线程能访问这些 synchronized 方法。
 *
 *      2：对象锁：锁的是当前对象的 this，被锁定后，其他的线程不能进入到当前对象的其他的 synchronized 方法中。
 *
 *      3：普通方法和同步方法无关。
 *
 *      4：换成两个对象后，不是同一把锁，情况变化，因为你用你的，我用我的，互不冲突。
 *
 *      5：Java中的每一个对象都可以作为锁 - synchronized
 *              对于普通同步方法，锁是当前实例对象。
 *              对于同步方法块，锁是 synchronized括号里配置的对象
 *              对于静态同步方法，锁是当前类的class对象。
 *
 *      6：当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。
 *          也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁。
 *         当别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，即有两个对象后，不需要等待该实例对象已获取
 *          锁的非静态同步方法释放锁就可以获取他们自身的锁。
 *
 *      7：所有的静态同步方法用的也是同一把送 - 类对象 class 本身。
 *          一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁。而不管是同一个实例对象的静态同步方法之间，
 *           还是不同的实例对象的静态同步方法之间，只要它们是同一个类的实例对象。
 *
 *
 * @author: Liao
 */
public class LockFlow {

    public static void main(String[] args) {

        Phone phone1 = new Phone();
        Phone phone2 = new Phone();


        new Thread(Phone::sendEmail,"a").start();

        new Thread(phone2::sendSMS, "b").start();
    }

}

class Phone {

    public static synchronized void sendEmail() {
        try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }
        System.out.println("发送邮件");
    }

    public synchronized void sendSMS() {
        System.out.println("发送短信");
    }

    public void seyHello() {
        System.out.println("hello");
    }
}
