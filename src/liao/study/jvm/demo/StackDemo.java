package liao.study.jvm.demo;

/*
 * @description:
 *  JVM 栈
 *      栈管运行，堆管存储
 *
 *      栈：
 *          1：线性表，特性：先进后出
 *              类比子弹，第一颗子弹压入后，肯定在栈底，即该子弹是最后出。
 *          2：线程私有，虽着线程生命周期结束而结束，等于创建一个线程就随之创建了一个栈。
 *          3：方法参数列表中的变量，方法体中的基本数据类型的变量和类型的引用都在其中，成员变量
 *              和对象本身不存放在栈中。运行时，成员函数的局部变量引用也存放在栈中。
 *          4：栈的变量虽着变量作用域的结束而释放，不需要JVM垃圾回收机制回收。
 *
 *      栈中主要存储的有：八种基本类型的变量 - 对象的引用变量 - 实例方法。
 *
 *      栈运行原理案例：方法A被调用，创建栈帧A1，并被压入栈中，
 *                      方法A中调用了方法B，创建栈帧B1，也被压入栈中，
 *                      方法B中又调用了方法C，又创建栈帧C1，也被压入栈中。
 *                      执行完成后，先弹出C，在B，在A。（原则：先进后出，后进先出）
 *                          （每个方法执行的同时都会创建一个栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等信息，
 *                              每一个方法从调用知道执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程）
 *
 *      栈帧：
 *          简单理解：栈帧即Java层面中的方法。
 *          栈帧中主要保存的三类数据：
 *              1：本地变量：输入参数和输出参数以及方法内的变量。
 *              2：栈操作：记录出栈，入栈操作。
 *              3：栈帧数据：包括类文件，方法等。
 *
 *
 *      栈和堆的一些解释：
 *          1、从软件设计角度分析，栈代表了处理逻辑，堆代表了数据，这样分开，使得处理逻辑更清晰。
 *              分而治之的思想，这种隔离、模块化的思想体现在软件中的很多地方。
 *
 *          2、堆和栈的分离，使得堆的内容可以被多个栈共享（即多个线程访问同一个对象）。这种共享的收益很多，
 *              这种共享提供了一种有效的数据交互方式（共享内存），另一方面，堆中共享的常量和缓存可以被所有栈访问，节省了内存。
 *
 *          3、栈因为运行是需要，比如保存系统运行的上下文，需要地址段的划分，由于栈只能向上增长，因此限制住栈存储内容的能力，
 *              而堆是根据需要可以动态增长的，因此栈和堆的拆分，使得堆动态增长成为可能，相应栈只需要记住堆中的一个地址即可。
 *
 *          4、面向对象就是堆和栈的完美结合。其实，面向对象方式的程序与以前结构化的程序在执行上没有任何区别。但是，面向对象的引入，
 *              使得对待问题的思考方式发生了改变，而更接近于自然方式的思考。当我们把对象拆开，你会发现，对象的属性其实就是数据，
 *              存放在堆中；而对象的行为（方法），就是运行逻辑，放在栈中。我们在编写对象的时候，其实即编写了数据结构，
 *              也编写的处理数据的逻辑。不得不承认，面向对象的设计，确实很美
 *
 *
 *      详情参考：
 *          https://www.cnblogs.com/cherish010/p/8572710.html - 栈和堆
 *          https://blog.csdn.net/qq_32258777/article/details/81353638 - 栈和栈帧
 *
 * @author: Liao
 * @date  2020/4/15 21:07
 */
public class StackDemo {

    /**
     * 栈帧中的三类数据中的第一类：本地变量：输入参数和输出参数以及方法内的变量。
     * @return
     */
    public String helloStack(String a, String b) {
        String c = a + b;
        return c;
    }

    public static void main(String[] args) {

    }

}
